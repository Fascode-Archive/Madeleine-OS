// Code generated by cmd/cgo; DO NOT EDIT.

//line /tmp/build_aur/yay/src/yay-9.4.2/vendor/github.com/Jguer/go-alpm/types.go:1:1
// types.go - libalpm types.
//
// Copyright (c) 2013 The go-alpm Authors
//
// MIT Licensed. See LICENSE for details.

package alpm

// #cgo CFLAGS: -D_FILE_OFFSET_BITS=64
// #include <alpm.h>
import _ "unsafe"

import (
	"errors"
	"fmt"
	"reflect"
	"unsafe"
)

// Depend provides a description of a dependency.
type Depend struct {
	Name        string
	Version     string
	Description string
	NameHash    uint
	Mod         DepMod
}

func convertDepend(dep * /*line :29:25*/_Ctype_struct__alpm_depend_t /*line :29:40*/) Depend {
	return Depend{
		Name:        ( /*line :31:16*/_Cfunc_GoString /*line :31:25*/)(dep.name),
		Version:     ( /*line :32:16*/_Cfunc_GoString /*line :32:25*/)(dep.version),
		Mod:         DepMod(dep.mod),
		Description: ( /*line :34:16*/_Cfunc_GoString /*line :34:25*/)(dep.desc),
		NameHash:    uint(dep.name_hash),
	}
}

func convertCDepend(dep Depend) * /*line :39:34*/_Ctype_struct__alpm_depend_t /*line :39:49*/ {
	cName := ( /*line :40:11*/_Cfunc_CString /*line :40:19*/)(dep.Name)
	cVersion := ( /*line :41:14*/_Cfunc_CString /*line :41:22*/)(dep.Version)
	cDesc := ( /*line :42:11*/_Cfunc_CString /*line :42:19*/)(dep.Description)

	cDep :=  /*line :44:10*/_Ctype_struct__alpm_depend_t /*line :44:25*/{
		name:      cName,
		version:   cVersion,
		desc:      cDesc,
		name_hash:  /*line :48:14*/_Ctype_ulong /*line :48:21*/(dep.NameHash),
		mod:        /*line :49:14*/_Ctype_alpm_depmod_t /*line :49:29*/(dep.Mod),
	}

	return &cDep
}

func freeCDepend(dep * /*line :55:23*/_Ctype_struct__alpm_depend_t /*line :55:38*/) {
	defer func() func() { _cgo0 := /*line :56:15*/unsafe.Pointer(dep.name); return func() { _cgoCheckPointer(_cgo0); _Cfunc_free(_cgo0); }}()()
	defer func() func() { _cgo0 := /*line :57:15*/unsafe.Pointer(dep.version); return func() { _cgoCheckPointer(_cgo0); _Cfunc_free(_cgo0); }}()()
	defer func() func() { _cgo0 := /*line :58:15*/unsafe.Pointer(dep.desc); return func() { _cgoCheckPointer(_cgo0); _Cfunc_free(_cgo0); }}()()
}

func (dep Depend) String() string {
	return dep.Name + dep.Mod.String() + dep.Version
}

// File provides a description of package files.
type File struct {
	Name string
	Size int64
	Mode uint32
}

func convertFile(file * /*line :72:24*/_Ctype_struct__alpm_file_t /*line :72:37*/) (File, error) {
	if file == nil {
		return File{}, errors.New("No file")
	}
	return File{
		Name: ( /*line :77:9*/_Cfunc_GoString /*line :77:18*/)(file.name),
		Size: int64(file.size),
		Mode: uint32(file.mode)}, nil
}

func convertFilelist(files * /*line :82:29*/_Ctype_struct__alpm_filelist_t /*line :82:46*/) []File {
	size := int(files.count)
	items := make([]File, size)

	rawItems := reflect.SliceHeader{
		Len:  size,
		Cap:  size,
		Data: uintptr(unsafe.Pointer(files.files))}

	cFiles := *(*[] /*line :91:17*/_Ctype_struct__alpm_file_t /*line :91:30*/)(unsafe.Pointer(&rawItems))

	for i := 0; i < size; i++ {
		if file, err := convertFile(&cFiles[i]); err == nil {
			items[i] = file
		}
	}
	return items
}

// Internal alpm list structure.
type list struct {
	Data unsafe.Pointer
	Prev *list
	Next *list
}

// Iterates a function on a list and stop on error.
func (l *list) forEach(f func(unsafe.Pointer) error) error {
	for ; l != nil; l = l.Next {
		err := f(l.Data)
		if err != nil {
			return err
		}
	}
	return nil
}

func (l *list) Len() int {
	count := 0
	for ; l != nil; l = l.Next {
		count++
	}
	return count
}

func (l *list) Empty() bool {
	return l == nil
}

type StringList struct {
	*list
}

func (l StringList) ForEach(f func(string) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		return f(( /*line :137:12*/_Cfunc_GoString /*line :137:21*/)((* /*line :137:25*/_Ctype_char /*line :137:31*/)(p)))
	})
}

func (l StringList) Slice() []string {
	slice := []string{}
	l.ForEach(func(s string) error {
		slice = append(slice, s)
		return nil
	})
	return slice
}

type BackupFile struct {
	Name string
	Hash string
}

type BackupList struct {
	*list
}

func (l BackupList) ForEach(f func(BackupFile) error) error {
	return l.forEach(func(p unsafe.Pointer) error {
		bf := (* /*line :161:11*/_Ctype_struct__alpm_backup_t /*line :161:26*/)(p)
		return f(BackupFile{
			Name: ( /*line :163:10*/_Cfunc_GoString /*line :163:19*/)(bf.name),
			Hash: ( /*line :164:10*/_Cfunc_GoString /*line :164:19*/)(bf.hash),
		})
	})
}

func (l BackupList) Slice() (slice []BackupFile) {
	l.ForEach(func(f BackupFile) error {
		slice = append(slice, f)
		return nil
	})
	return
}

type QuestionAny struct {
	ptr * /*line :178:7*/_Ctype_struct__alpm_question_any_t /*line :178:28*/
}

func (question QuestionAny) SetAnswer(answer bool) {
	if answer {
		question.ptr.answer = 1
	} else {
		question.ptr.answer = 0
	}
}

type QuestionInstallIgnorepkg struct {
	ptr * /*line :190:7*/_Ctype_struct__alpm_question_install_ignorepkg_t /*line :190:42*/
}

func (question QuestionAny) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionAny) Answer() bool {
	return question.ptr.answer == 1
}

func (question QuestionAny) QuestionInstallIgnorepkg() (QuestionInstallIgnorepkg, error) {
	if question.Type() == QuestionTypeInstallIgnorepkg {
		return *(*QuestionInstallIgnorepkg)(unsafe.Pointer(&question)), nil
	}

	return QuestionInstallIgnorepkg{}, fmt.Errorf("Can not convert to QuestionInstallIgnorepkg")
}

func (question QuestionAny) QuestionSelectProvider() (QuestionSelectProvider, error) {
	if question.Type() == QuestionTypeSelectProvider {
		return *(*QuestionSelectProvider)(unsafe.Pointer(&question)), nil
	}

	return QuestionSelectProvider{}, fmt.Errorf("Can not convert to QuestionInstallIgnorepkg")
}

func (question QuestionAny) QuestionReplace() (QuestionReplace, error) {
	if question.Type() == QuestionTypeReplacePkg {
		return *(*QuestionReplace)(unsafe.Pointer(&question)), nil
	}

	return QuestionReplace{}, fmt.Errorf("Can not convert to QuestionReplace")
}

func (question QuestionInstallIgnorepkg) SetInstall(install bool) {
	if install {
		question.ptr.install = 1
	} else {
		question.ptr.install = 0
	}
}

func (question QuestionInstallIgnorepkg) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionInstallIgnorepkg) Install() bool {
	return question.ptr.install == 1
}

func (question QuestionInstallIgnorepkg) Pkg(h *Handle) Package {
	return Package{
		question.ptr.pkg,
		*h,
	}
}

type QuestionReplace struct {
	ptr * /*line :249:7*/_Ctype_struct__alpm_question_replace_t /*line :249:32*/
}

func (question QuestionReplace) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionReplace) SetReplace(replace bool) {
	if replace {
		question.ptr.replace = 1
	} else {
		question.ptr.replace = 0
	}
}

func (question QuestionReplace) Replace() bool {
	return question.ptr.replace == 1
}

func (question QuestionReplace) NewPkg(h *Handle) *Package {
	return &Package{
		question.ptr.newpkg,
		*h,
	}
}

func (question QuestionReplace) OldPkg(h *Handle) *Package {
	return &Package{
		question.ptr.oldpkg,
		*h,
	}
}

func (question QuestionReplace) newDB(h *Handle) *DB {
	return &DB{
		question.ptr.newdb,
		*h,
	}
}

type QuestionSelectProvider struct {
	ptr * /*line :290:7*/_Ctype_struct__alpm_question_select_provider_t /*line :290:40*/
}

func (question QuestionSelectProvider) Type() QuestionType {
	return QuestionType(question.ptr._type)
}

func (question QuestionSelectProvider) SetUseIndex(index int) {
	question.ptr.use_index =  /*line :298:27*/_Ctype_int /*line :298:32*/(index)
}

func (question QuestionSelectProvider) UseIndex() int {
	return int(question.ptr.use_index)
}

func (question QuestionSelectProvider) Providers(h *Handle) PackageList {
	return PackageList{
		(*list)(unsafe.Pointer(question.ptr.providers)),
		*h,
	}
}

func (question QuestionSelectProvider) Dep() Depend {
	return convertDepend(question.ptr.depend)
}
